{"version":3,"file":"gaateschema-form-react.js","sources":["../../src/createForm.jsx","../../src/reducer.js"],"sourcesContent":["import React, {Component} from 'react'\nimport PropTypes from 'prop-types'\nimport defaultTransformer from 'gateschema-transformer'\n\nfunction debounce(func, wait) {\n  let tId\n  return function() {\n    clearTimeout(tId)\n    tId = setTimeout(() => {\n      tId = null\n      func.apply(this, arguments)\n    }, wait)\n  }\n}\n\nexport function createForm(options = {}) {\n  const { StateForm, transformer = defaultTransformer } = options\n\n  class GateSchemaForm extends Component {\n    static contextTypes = {\n      store: PropTypes.object\n    }\n    static propTypes = {\n      schema: PropTypes.object.isRequired,\n      value: PropTypes.any,\n      name: PropTypes.string,\n      debounce: PropTypes.number,\n      ignoreErrors: PropTypes.object\n    }\n    constructor(props, context) {\n      super(props, context)\n      const {schema, value, name, debounce }  = props\n\n      this.cache = {}\n      this.errors = []\n      this.activePaths = {}\n      this.validationOptions = {\n          skipAsync: true,\n          useCache: true\n      }\n      this.submitValidationOptions = {\n        useCache: true\n      }\n      this.pathValidationOptions = {}\n\n      this.state = {\n        schema: schema,\n        value: value,\n        formState: null\n      }\n\n      this.setValueOfFormPath = name \n        ? this.setValueOfFormPathViaRedux \n        : this.setValueOfFormPathDirectly\n\n      this.renderSchemaDebounced = debounce \n        ? debounce(this.renderSchema, debounce) \n        : this.renderSchema\n\n      if (props.schema) {\n        this.renderSchema()\n      }\n    }\n    setValueOfFormPathDirectly(path, value, parentValue, key) {\n      parentValue[key] = value\n    }\n    setValueOfFormPathViaRedux(path, value, parentValue, key) {\n      this.context.store.dispatch({\n        type: 'GATESCHEMA_FORM_INPUT_OF_PATH',\n        payload: {\n          name: this.props.name,\n          path,\n          value,\n          parentValue,\n          key\n        }\n      })\n    }\n    transformNode = (node, parentNode) => {\n      const {activePaths} = this\n      const {ignoreErrors} = this.props\n      const {path, error, value, constraints} = node\n      const {type, other = {}} = constraints\n      const form = other.form || {}\n\n      if (form.hidden) {\n        return\n      }\n      let errorMsg\n\n      // collect error\n      if (error && !ignoreErrors[error.keyword]) {\n        this.errors.push(error)\n        errorMsg = error.msg\n      }\n\n      const formItem =  Object.assign({}, form, {\n        path,\n        required: constraints.required,\n        error: (activePaths[path] && errorMsg) || undefined,\n        value,\n        children: node.children,\n        option: constraints.option\n      })\n\n\n      const componentMap = {\n        list: 'List',\n        map: 'Map',\n        string: 'Input',\n        number: 'InputNumber',\n        boolean: 'Switch',\n        enumList: 'Checkbox',\n        enum: 'Radio'\n      }\n\n      let component = formItem.component || (path === '/' ? 'Form' :  componentMap[type])\n\n\n      if (component === 'Select' && type === 'enumList') {\n        formItem.multiple = true\n      }\n\n      if (!formItem.label && parentNode && parentNode.constraints.type !== 'list') {\n        formItem.label = path.slice(path.lastIndexOf('/') + 1)\n      }\n\n      formItem.component = component\n\n      this.cache[path] = {\n        type,\n        item: formItem\n      }\n      return formItem\n    }\n    setFormState(formState) {\n      const state = this.state\n      const {schema, value} = state\n      if (state.formState == null) {\n        this.state = {\n          schema,\n          value,\n          formState\n        }\n      } else {\n        this.setState({\n          schema,\n          value,\n          formState\n        })\n      }\n    }\n    updateValue(path, value, noDebounce) {\n      const rootData = this.props.value\n      const keys = path.split('/').slice(1)\n      const length = keys.length\n      if (length === 0) {\n        return this.setValueOfFormPath('/', value)\n      }\n      let target = rootData || {}\n      if (target !== rootData) {\n        this.setValueOfFormPath('/', target)\n      }\n\n      const lastIndex = length - 1\n      let currentPath = ''\n      for(let i = 0; i < length; i++) {\n        const key = keys[i]\n        currentPath += ('/' + key)\n        if (i < lastIndex) {\n          let child = target[key]\n          if (child == null || typeof child !== 'object') {\n            child = this.cache[currentPath].type === 'list' ? [] : {}\n            this.setValueOfFormPath(currentPath, child, target, key)\n          }\n          target = child\n        } else {\n          this.setValueOfFormPath(currentPath, value, target, key)\n        }\n      }\n      return noDebounce ? this.renderSchema() : this.renderSchemaDebounced()\n    }\n    handleUserInput = (path, value, index) => {\n      let noDebounce = false\n      const type = this.cache[path].type\n      if (type === 'string' && value === '') {\n        value = undefined\n      } else if (type === 'list') {\n        noDebounce = true\n        if (typeof index !== 'undefined') {\n          const activePaths = this.activePaths\n          const newActivePaths = {}\n          const activePathsOfOldValue = []\n          const prefix = path + '/'\n          Object.keys(activePaths).forEach(key => {\n            if (key.indexOf(prefix) === 0) {\n              activePathsOfOldValue.push(key)\n            } else {\n              newActivePaths[key] = true\n            }\n          })\n          const regex = new RegExp('^' + path + '\\\\/(\\\\d)(\\\\/.*)?')\n          let match\n          let idx\n          let appendix\n          activePathsOfOldValue.forEach(oldKey => {\n            match = oldKey.match(regex)\n            idx = ~~match[1]\n            appendix = match[2] || ''\n            if (idx < index) {\n              newActivePaths[oldKey] = true\n            } else if (idx > index) {\n              newActivePaths[prefix + (idx - 1) + appendix] = true\n            }\n          })\n          this.activePaths = newActivePaths\n        }\n      }\n      this.activePaths[path] = true\n      this.pathValidationOptions = {\n        [path]: {\n          skipAsync: false\n        }\n      }\n      this.updateValue(path, value, noDebounce)\n    }\n    handleSubmit = () => {\n      const activePaths = this.activePaths\n      Object.keys(this.cache).forEach(key => {\n        activePaths[key] = true\n      })\n      this.renderSchema({\n        validationOptions: this.submitValidationOptions, \n        cb: () => {\n          this.props.onSubmit(this.errors)\n        }\n      })\n    }\n    handleReset() {\n      this.props.onReset()\n    }\n    renderSchema = (options = {}) => {\n      const {\n        validationOptions: defaultValidationOptions, \n        pathValidationOptions: defaultPathValidationOptions\n      } = this\n      const {cb, \n        validationOptions = defaultValidationOptions, \n        pathValidationOptions = defaultPathValidationOptions\n      } = options\n      const {value, schema} = this.state\n      this.errors = []\n      this.cache = {}\n      const transformOptions = {\n        path: '/',\n        value: value,\n        rootData: value,\n        validationOptions,\n        pathValidationOptions,\n        transform: this.transformNode,\n      }\n      transformer.transform(schema, transformOptions, (formState) => {\n        this.setFormState(formState)\n        return cb && cb()\n      })\n    }\n    componentWillReceiveProps(nextProps) {\n      const props = this.props\n      const {value, schema} = nextProps\n      if (props.value !== value || props.schema !== schema) {\n        this.setState({\n          value: value,\n          schema: schema,\n          formState: this.state.formState\n        })\n        this.renderSchema()\n      }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n      if (this.state.formState === nextState.formState) {\n        return fasle\n      } \n      return true\n    }\n    render() {\n      const {handleSubmit, handleReset, handleUserInput, children} = this\n      const {formState} = this.state\n      return <StateForm \n        state={formState} \n        onSubmit={handleSubmit}\n        onReset={handleReset}\n        onInput={handleUserInput}\n      >\n        {children}\n      </StateForm>\n    }\n    created() {\n      if (this.name) {\n        const name = this.name\n        const mutationsName = vuexModuleName + '/setValueOfFormPath'\n        this.setValueOfFormPath = function(path, value, parentValue, key) {\n          this.$store.commit(mutationsName, {\n            name,\n            path,\n            value,\n            parentValue,\n            key\n          })\n        }\n      }\n\n      this.$watch('schema', {\n        deep: this.isDeepWatchSchema,\n        handler: this.renderSchema\n      })\n\n      this.renderSchemaDebounced = this.debounce \n        ? debounce(this.renderSchema, this.debounce) \n        : this.renderSchema\n      \n      if (this.schema) {\n        this.renderSchemaDebounced()\n      }\n    }\n  }\n  GateSchemaForm.defaultProps = {\n    ignoreErrors: {\n      map: true,\n      list: true\n    }\n  }\n\n  return GateSchemaForm\n}\n\nexport default createForm\n","export default function reducer(state = {}, action = {}) {\n  const {type, payload} = action\n  if (type === 'GATESCHEMA_FORM_INPUT_OF_PATH') {\n   const {name, path, value, parentValue, key} = payload \n   if (path === '/') {\n     return Object.assign({}, state, {\n       [name]: value\n     })\n   } else {\n     parentValue[key] = value\n     return Object.assign({}, state)\n   }\n  }\n  return state\n}"],"names":["options","StateForm","transformer","defaultTransformer","GateSchemaForm","props","context","node","parentNode","activePaths","ignoreErrors","_this2","path","error","value","constraints","type","other","form","hidden","errorMsg","keyword","errors","push","msg","formItem","Object","assign","required","undefined","children","option","component","list","map","string","number","boolean","enumList","enum","multiple","label","slice","lastIndexOf","cache","item","index","noDebounce","newActivePaths","activePathsOfOldValue","prefix","keys","forEach","key","indexOf","match","idx","appendix","regex","RegExp","oldKey","pathValidationOptions","skipAsync","updateValue","renderSchema","validationOptions","submitValidationOptions","cb","onSubmit","defaultValidationOptions","defaultPathValidationOptions","state","schema","transformOptions","rootData","transform","transformNode","formState","setFormState","name","debounce","useCache","setValueOfFormPath","setValueOfFormPathViaRedux","setValueOfFormPathDirectly","renderSchemaDebounced","Component","parentValue","store","dispatch","payload","this","setState","split","length","target","lastIndex","currentPath","i","child","_typeof","onReset","nextProps","nextState","fasle","handleSubmit","handleReset","handleUserInput","React","onInput","mutationsName","vuexModuleName","$store","commit","func","wait","tId","$watch","deep","isDeepWatchSchema","handler","clearTimeout","setTimeout","apply","_this","arguments","PropTypes","object","isRequired","any","defaultProps","action"],"mappings":"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"}